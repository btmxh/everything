- theorem: stuff is either true or false
- problem: find stuff
	- repr as $A\to B$
		- A: preprositions -> input
		- B: objective, aim, etc. -> output
		- $\to$: the thing we need to find/do -> program
	- to solve a problem, one is given the input and output, tasked to determine how to transform A in a finite amt of steps into B
	- one uses [[computer]]s to solve [[it/intro/algo/algo#problems|problems]] via [[program]]s
=> [[program]]: encoded algorithm as macine lang

> computers: can't think, not intelligent, sentient, etc.
> humans, programmer: must analyze the problem (find A, B) -> give the computer instructions

## phases
- determine the problem
- find the method of solution (pp giair)
- construct solution/algo
	- directly solve the problem
		- trivial => used in education purposes
		- this does not work for all problems (ofc)
	- search for solution
		- brute-force, trial n error (try all possible combinations)
		- random (randomize some combination)
		- backtracking (partially construct combination -> one can eliminate a class of combinations if something is wrong)
- implement program
	- use [[program]]ming lang (low level, high level, etc.)
- adjust program
	- compile fix build errors, warnings, unit tests, etc.
- execute/release program

## problem categorization
- algorithmic complexity
	- space/memory complexity
	- time complexity
- polynomial deterministic, ... (he gave up xddddddd)
